场景介绍：
现在有一个订单处理的系统，里面有一个保存订单的业务功能。在这个业务功能中，客户有这样一个需求：每当订单的预定产品数量超过1000的时候，
就需要把订单拆成两份订单来保存。如果拆成两份订单后，还是超过1000，那就继续拆分，直到每份订单的预定产品数量不超过1000。至于为什么
要拆分，原因是方便进行订单的后续处理，后续是由人工来处理，每个人工工作小组的处理能力上限是1000。根据业务，目前的订单类型被分成两种：
一种是个人订单，一种是公司订单。现在想要实现一个通用的订单处理系统，也就是说，不管具体是什么类型的订单，都要能够正常地处理。

不用模式的解决方案：
首先，要想实现通用的订单处理系统，而不关心具体的订单类型，那么很明显，订单处理的对象要么面向一个接口，要么面向一个通用的订单对象，这里
选用面向订单的接口来编程。先把订单的接口定义出来:OrderApi,再实现各种类型的具体的订单,PersonalOrder , 
EnterpriseOrder。接下来实现通用的订单处理OrderBusiness。

原型模式：
本质：克隆生成对象
用法：如果面向的是接口，则接口提供一个克隆的方法，在具体类中实现这个克隆方法。如果面向对象，直接实现克隆方法就行。

具体实现：
实现克隆方法时，一般是直接new一个新对象，然后对其赋值，或者实现Clonable接口并重写clone方法，注意后一种方法时浅克隆，当对象内
有对象引用时还需要实现该对象的克隆，并设置到新对象上。
